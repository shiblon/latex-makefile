(##include_as_comment("copyright") ##)
#
# TO OBTAIN INSTRUCTIONS FOR USING THIS FILE, RUN:
#    make help
#
fileinfo	:= LaTeX Makefile
author		:= Chris Monson
version		:= 2.2.0-rc13
#
# Note that the user-global version is imported *after* the source directory,
# so that you can use stuff like ?= to get proper override behavior.
.PHONY: Makefile GNUmakefile Makefile.ini $(HOME)/.latex-makefile/Makefile.ini
-include Makefile.ini
-include $(HOME)/.latex-makefile/Makefile.ini
#
# This can be pdflatex or latex - you can change this by adding the following line to your Makefile.ini:
# BUILD_STRATEGY := latex
BUILD_STRATEGY		?= pdflatex
#
# Sets LC_ALL=C, by default, so that the locale-aware tools, like sort, be
# # immune to changes to the locale in the user environment.
export LC_ALL		?= C
#
#
# If you specify sources here, all other files with the same suffix
# will be treated as if they were _include_ files.
#onlysources.tex	?= main.tex
#onlysources.tex.sh	?=
#onlysources.tex.pl	?=
#onlysources.tex.py	?=
#onlysources.rst	?=
#onlysources.fig	?=
#onlysources.gpi	?=
#onlysources.dot	?=
#onlysources.xvg	?=
#onlysources.svg	?=
#onlysources.eps.gz	?=
#onlysources.eps	?=
#
# If you list files here, they will be treated as _include_ files
#includes.tex		?= file1.tex file2.tex
#includes.tex.sh	?=
#includes.tex.pl	?=
#includes.tex.py	?=
#includes.rst		?=
#includes.fig		?=
#includes.gpi		?=
#includes.dot		?=
#includes.xvg		?=
#includes.svg		?=
#includes.eps.gz	?=
#includes.eps		?=
#
# If you list files or wildcards here, they will *not* be cleaned - default is
# to allow everything to be cleaned.
#neverclean		?= *.pdf
#
# Alternatively (recommended), you can add those lines to a Makefile.ini file
# and it will get picked up automatically without your having to edit this
# Makefile.
#
# KNOWN ISSUES:
(##include_as_comment("known-issues") ##)
#
# CHANGES:
(##include_as_comment("changes") ##)

# IMPORTANT!
#
# When adding to the following list, do not introduce any blank lines.  The
# list is extracted for documentation using sed and is terminated by a blank
# line.
#
# EXTERNAL PROGRAMS:
# = ESSENTIAL PROGRAMS =
# == Basic Shell Utilities ==
CAT		?= cat
CP		?= cp -f
DIFF		?= diff
ECHO		?= echo
EGREP		?= egrep
ENV		?= env
EXPR		?= expr
MV		?= mv -f
SED		?= sed
SORT		?= sort
TOUCH		?= touch
UNIQ		?= uniq
WHICH		?= which
XARGS		?= xargs
SLEEP		?= sleep
# == LaTeX (tetex-provided) ==
BIBTEX		?= bibtex
DVIPS		?= dvips
LATEX		?= latex
PDFLATEX	?= pdflatex
XELATEX		?= xelatex
EPSTOPDF	?= epstopdf
MAKEINDEX	?= makeindex
KPSEWHICH	?= kpsewhich
GS		?= gs
# = OPTIONAL PROGRAMS =
# == For MikTex under Cygwin, to get path names right
CYGPATH		?= cygpath
# == Makefile Color Output ==
TPUT		?= tput
# == TeX Generation ==
PERL		?= perl
PYTHON		?= python
RST2LATEX	?= rst2latex.py
# == EPS Generation ==
CONVERT		?= convert	# ImageMagick
DOT		?= dot		# GraphViz
DOT2TEX		?= dot2tex	# dot2tex - add options (not -o) as needed
FIG2DEV		?= fig2dev	# XFig
GNUPLOT		?= gnuplot	# GNUplot
INKSCAPE	?= inkscape	# Inkscape (svg support)
XMGRACE		?= xmgrace	# XMgrace
PNGTOPNM	?= pngtopnm	# From NetPBM - step 1 for png -> eps
PPMTOPGM	?= ppmtopgm	# From NetPBM - (gray) step 2 for png -> eps
PNMTOPS		?= pnmtops	# From NetPBM - step 3 for png -> eps
GUNZIP		?= gunzip	# GZipped EPS
# == Beamer Enlarged Output ==
PSNUP		?= psnup
# == Viewing Stuff ==
VIEW_POSTSCRIPT	?= gv
VIEW_PDF	?= xpdf
VIEW_GRAPHICS	?= display

# If cygpath is present, then we create a path-norm function that uses it,
# otherwise the function is just a no-op.  Issue 112 has details.
USE_CYGPATH := $(if $(shell $(WHICH) $(CYGPATH) 2>/dev/null),yes,)

# $(call get-cygpath,<path>)
define get-cygpath
$(shell $(CYGPATH) -u "$(shell $(CYGPATH) -s -w $1)")
endef

define path-norm
$(if $(USE_CYGPATH),$(call get-cygpath,$1),$1)
endef

# Command options for embedding fonts and postscript->pdf conversion
PS_EMBED_OPTIONS	?= -dPDFSETTINGS=/printer -dEmbedAllFonts=true -dSubsetFonts=true -dMaxSubsetPct=100
PS_COMPATIBILITY	?= 1.4

# If set to something, will cause temporary files to not be deleted immediately
KEEP_TEMP	?=

# Defaults for GPI
DEFAULT_GPI_EPS_FONTSIZE	?= 22
DEFAULT_GPI_PDF_FONTSIZE	?= 12

# Style file for ReST
RST_STYLE_FILE			?= $(wildcard _rststyle_._include_.tex)

# This ensures that even when echo is a shell builtin, we still use the binary
# (the builtin doesn't always understand -n)
FIXED_ECHO	:= $(if $(findstring -n,$(shell $(ECHO) -n)),$(shell which echo),$(ECHO))
ECHO		:= $(if $(FIXED_ECHO),$(FIXED_ECHO),$(ECHO))

define determine-gnuplot-output-extension
$(if $(shell $(WHICH) $(GNUPLOT) 2>/dev/null),
     $(if $(findstring unknown or ambiguous, $(shell $(GNUPLOT) -e "set terminal pdf" 2>&1)),
	  eps, pdf),
     none)
endef

GNUPLOT_OUTPUT_EXTENSION	?= $(strip $(call determine-gnuplot-output-extension))

# Internal code should use this because of :=.  This means that the potentially
# expensive script invocation used to determine whether pdf is available will
# only be run once.
GPI_OUTPUT_EXTENSION := $(strip $(GNUPLOT_OUTPUT_EXTENSION))

# Note, if the terminal *does* understand fsize, then we expect this call to
# create a specific error here: "fsize: expecting font size".  Otherwise, we
# assume that fsize is not understood.
GPI_FSIZE_SYNTAX := $(strip \
$(if \
  $(filter pdf,$(GPI_OUTPUT_EXTENSION)),\
  $(if \
    $(findstring fsize: expecting font size,$(shell $(GNUPLOT) -e "set terminal pdf fsize" 2>&1)),\
    fsize FONTSIZE,\
    font ",FONTSIZE"),\
  FONTSIZE))

# Directory into which we place "binaries" if it exists.
# Note that this can be changed on the commandline or in Makefile.ini:
#
# Command line:
#   make BINARY_TARGET_DIR=$HOME/pdfs myfile.pdf
#
# Also, you can specify a relative directory (relative to the Makefile):
#   make BINARY_TARGET_DIR=pdfs myfile.pdf
#
# Or, you can use Makefile.ini:
#
#   BINARY_TARGET_DIR := $(HOME)/bin_out
#
BINARY_TARGET_DIR	?= _out_

RESTARTS		:= $(if $(MAKE_RESTARTS),$(MAKE_RESTARTS),0)
# SH NOTES
#
# On some systems, /bin/sh, which is the default shell, is not linked to
# /bin/bash.  While bash is supposed to be sh-compatible when invoked as sh, it
# just isn't.  This section details some of the things you have to stay away
# from to remain sh-compatible.
#
#	* File pattern expansion does not work for {}
#	* [ "$x" = "$y" ] has to be [ x"$x" x"$y" ]
#	* &> for stderr redirection doesn't work, use 2>&1 instead
#
# BSD SED NOTES
#
# BSD SED is not very nice compared to GNU sed, but it is the most
# commonly-invoked sed on Macs (being based on BSD), so we have to cater to
# it or require people to install GNU sed.  It seems like the GNU
# requirement isn't too bad since this makefile is really a GNU makefile,
# but apparently GNU sed is much less common than GNU make in general, so
# I'm supporting it here.
#
# Sad experience has taught me the following about BSD sed:
#
# 	* \+ is not understood to mean \{1,\}
# 	* \| is meaningless (does not branch)
# 	* \n cannot be used as a substitution character
# 	* ? does not mean \{0,1\}, but is literal
# 	* a\ works, but only reliably for a single line if subsequent lines
# 		have forward slashes in them (as is the case in postscript)
#
# For more info (on the Mac) you can consult
#
# man -M /usr/share/man re_format
#
# And look for the word "Obsolete" near the bottom.

#
# EXTERNAL PROGRAM DOCUMENTATION SCRIPT
#

# $(call output-all-programs,[<output file>])
define output-all-programs
	[ -f '$(this_file)' ] && \
	$(SED) \
		-e '/^[[:space:]]*#[[:space:]]*EXTERNAL PROGRAMS:/,/^$$/!d' \
		-e '/EXTERNAL PROGRAMS/d' \
		-e '/^$$/d' \
		-e '/^[[:space:]]*#/i\ '\
		-e 's/^[[:space:]]*#[[:space:]][^=]*//' \
		$(this_file) $(if $1,> '$1',) || \
	$(ECHO) "Cannot determine the name of this makefile."
endef

# If they misspell gray, it should still work.
GRAY	?= $(call get-default,$(GREY),)

#
# Utility Functions and Definitions
#

# Don't call this directly - it is here to avoid calling wildcard more than
# once in remove-files.
remove-files-helper	= $(if $1,$(RM) $1,$(sh_true))

# $(call remove-files,file1 file2)
remove-files		= $(call remove-files-helper,$(wildcard $1))

# Removes all cleanable files in the given list
# $(call clean-files,file1 file2 file3 ...)
# Works exactly like remove-files, but filters out files in $(neverclean)
clean-files		= \
	$(call remove-files-helper,$(call cleanable-files,$(wildcard $1)))

# Outputs all generated files to STDOUT, along with some others that are
# created by these (e.g., .idx files end up producing .ilg and .ind files).
# Discovered by reading *.fls OUTPUT lines and producing corresponding .ind
# filenames as needed.
#
# $(call get-generated-names,<source recorder file (*.fls)>)
define get-generated-names
[ -f '$1' ] && \
$(SED) \
	-e '/^OUTPUT /{' \
	-e '  s///' \
	-e '  p' \
	-e '  s/\.idx/\.ind/p' \
	-e '  s/\.ind/\.ilg/p' \
	-e '}' \
	-e 'd' \
	'$1' \
| $(SORT) | $(UNIQ)
endef

# This removes files without checking whether they are there or not.  This
# sometimes has to be used when the file is created by a series of shell
# commands, but there ends up being a race condition: make doesn't know about
# the file generation as quickly as the system does, so $(wildcard ...) doesn't
# work right.  Blech.
# $(call remove-temporary-files,filenames)
remove-temporary-files	= $(if $(KEEP_TEMP),:,$(if $1,$(RM) $1,:))

# Create an identifier from a file name
# $(call cleanse-filename,filename)
cleanse-filename	= $(subst .,_,$(subst /,__,$1))

# Escape dots
# $(call escape-fname-regex,str)
escape-fname-regex	= $(subst /,\\/,$(subst .,\\.,$1))

# Test that a file exists
# $(call test-exists,file)
test-exists		= [ -e '$1' ]

# $(call move-files,source,destination)
move-if-exists		= $(call test-exists,$1) && $(MV) '$1' '$2'

# Copy file1 to file2 only if file2 doesn't exist or they are different
# $(call copy-if-different,sfile,dfile)
copy-if-different	= $(call test-different,$1,$2) && $(CP) '$1' '$2'
copy-if-exists		= $(call test-exists,$1) && $(CP) '$1' '$2'
move-if-different	= $(call test-different,$1,$2) && $(MV) '$1' '$2'
replace-if-different-and-remove	= \
	$(call test-different,$1,$2) \
	&& $(MV) '$1' '$2' \
	|| $(call remove-files,'$1')

# Note that $(DIFF) returns success when the files are the SAME....
# $(call test-different,sfile,dfile)
test-different		= ! $(DIFF) -q '$1' '$2' >/dev/null 2>&1
test-exists-and-different	= \
	$(call test-exists,$2) && $(call test-different,$1,$2)

# Return value 1, or value 2 if value 1 is empty
# $(call get-default,<possibly empty arg>,<default value if empty>)
get-default	= $(if $1,$1,$2)

# Copy a file and log what's going on
# $(call copy-with-logging,<source>,<target>)
define copy-with-logging
if [ -d '$2/' ]; then \
	if $(CP) '$1' '$2/'; then \
		$(ECHO) "$(C_INFO)Copied '$1' to '$2/'$(C_RESET)"; \
	else \
		$(ECHO) "$(C_ERROR)Failed to copy '$1' to '$2/'$(C_RESET)"; \
	fi; \
fi
endef

# Gives a reassuring message about the failure to find include files
# $(call include-message,<list of include files>)
define include-message
$(strip \
$(if $(filter-out $(wildcard $1),$1),\
	$(shell $(ECHO) \
	"$(C_INFO)NOTE: You may ignore warnings about the"\
	"following files:" >&2;\
	$(ECHO) >&2; \
	$(foreach s,$(filter-out $(wildcard $1),$1),$(ECHO) '     $s' >&2;)\
	$(ECHO) "$(C_RESET)" >&2)
))
endef
# Characters that are hard to specify in certain places
space		:= $(empty) $(empty)
colon		:= \:
comma		:= ,

# Useful shell definitions
sh_true		:= :
sh_false	:= ! :

# Clear out the standard interfering make suffixes
.SUFFIXES:

# Turn off forceful rm (RM is usually mapped to rm -f)
ifdef SAFE_RM
RM	:= rm
endif

# Turn command echoing back on with VERBOSE=1
ifndef VERBOSE
QUIET	:= @
endif

# Turn on shell debugging with SHELL_DEBUG=1
# (EVERYTHING is echoed, even $(shell ...) invocations)
ifdef SHELL_DEBUG
SHELL	+= -x
endif

# Get the name of this makefile (always right in 3.80, often right in 3.79)
# This is only really used for documentation, so it isn't too serious.
ifdef MAKEFILE_LIST
this_file	:= $(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST))
else
this_file	:= $(wildcard GNUmakefile makefile Makefile)
endif

# Terminal color definitions

REAL_TPUT 	:= $(if $(NO_COLOR),,$(shell $(WHICH) $(TPUT)))

# $(call get-term-code,codeinfo)
# e.g.,
# $(call get-term-code,setaf 0)
get-term-code = $(if $(REAL_TPUT),$(shell $(REAL_TPUT) $1),)

black	:= $(call get-term-code,setaf 0)
red	:= $(call get-term-code,setaf 1)
green	:= $(call get-term-code,setaf 2)
yellow	:= $(call get-term-code,setaf 3)
blue	:= $(call get-term-code,setaf 4)
magenta	:= $(call get-term-code,setaf 5)
cyan	:= $(call get-term-code,setaf 6)
white	:= $(call get-term-code,setaf 7)
bold	:= $(call get-term-code,bold)
uline	:= $(call get-term-code,smul)
reset	:= $(call get-term-code,sgr0)

#
# User-settable definitions
#
LATEX_COLOR_WARNING	?= magenta
LATEX_COLOR_ERROR	?= red
LATEX_COLOR_INFO	?= green
LATEX_COLOR_UNDERFULL	?= magenta
LATEX_COLOR_OVERFULL	?= red bold
LATEX_COLOR_PAGES	?= bold
LATEX_COLOR_BUILD	?= cyan
LATEX_COLOR_GRAPHIC	?= yellow
LATEX_COLOR_DEP		?= green
LATEX_COLOR_SUCCESS	?= green bold
LATEX_COLOR_FAILURE	?= red bold

# Gets the real color from a simple textual definition like those above
# $(call get-color,ALL_CAPS_COLOR_NAME)
# e.g., $(call get-color,WARNING)
get-color	= $(subst $(space),,$(foreach c,$(LATEX_COLOR_$1),$($c)))

#
# STANDARD COLORS
#
C_WARNING	:= $(call get-color,WARNING)
C_ERROR		:= $(call get-color,ERROR)
C_INFO		:= $(call get-color,INFO)
C_UNDERFULL	:= $(call get-color,UNDERFULL)
C_OVERFULL	:= $(call get-color,OVERFULL)
C_PAGES		:= $(call get-color,PAGES)
C_BUILD		:= $(call get-color,BUILD)
C_GRAPHIC	:= $(call get-color,GRAPHIC)
C_DEP		:= $(call get-color,DEP)
C_SUCCESS	:= $(call get-color,SUCCESS)
C_FAILURE	:= $(call get-color,FAILURE)
C_RESET		:= $(reset)

#
# PRE-BUILD TESTS
#

# Check that clean targets are not combined with other targets (weird things
# happen, and it's not easy to fix them)
hascleangoals	:= $(if $(sort $(filter clean clean-%,$(MAKECMDGOALS))),1)
hasbuildgoals	:= $(if $(sort $(filter-out clean clean-%,$(MAKECMDGOALS))),1)
ifneq "$(hasbuildgoals)" ""
ifneq "$(hascleangoals)" ""
$(error $(C_ERROR)Clean and build targets specified together$(C_RESET)))
endif
endif

#
# VARIABLE DECLARATIONS
#

# Names of sed scripts that morph gnuplot files -- only the first found is used
GNUPLOT_SED	:= global-gpi.sed gnuplot.sed
GNUPLOT_GLOBAL	:= global._include_.gpi gnuplot.global

ifeq "$(strip $(BUILD_STRATEGY))" "latex"
default_graphic_extension	?= eps
latex_build_program		?= $(LATEX)
build_target_extension		?= dvi
hyperref_driver_pattern		?= hdvips
hyperref_driver_error		?= Using dvips: specify ps2pdf in the hyperref options.
endif

ifeq "$(strip $(BUILD_STRATEGY))" "pdflatex"
default_graphic_extension	?= pdf
latex_build_program		?= $(PDFLATEX)
build_target_extension		?= pdf
hyperref_driver_pattern		?= hpdf.*
hyperref_driver_error		?= Using pdflatex: specify pdftex in the hyperref options (or leave it blank).
endif

ifeq "$(strip $(BUILD_STRATEGY))" "xelatex"
default_graphic_extension	?= pdf
latex_build_program		?= $(XELATEX)
build_target_extension		?= pdf
hyperref_driver_pattern		?= hdvipdf.*
hyperref_driver_error		?= Using pdflatex: specify pdftex in the hyperref options (or leave it blank).
endif

# Files of interest
all_files.tex		?= $(wildcard *.tex)
all_files.tex.sh	?= $(wildcard *.tex.sh)
all_files.tex.pl	?= $(wildcard *.tex.pl)
all_files.tex.py	?= $(wildcard *.tex.py)
all_files.rst		?= $(wildcard *.rst)
all_files.fig		?= $(wildcard *.fig)
all_files.gpi		?= $(wildcard *.gpi)
all_files.dot		?= $(wildcard *.dot)
all_files.xvg		?= $(wildcard *.xvg)
all_files.svg		?= $(wildcard *.svg)
all_files.png		?= $(wildcard *.png)
all_files.jpg		?= $(wildcard *.jpg)
all_files.jpeg		?= $(wildcard *.jpeg)
all_files.eps.gz	?= $(wildcard *.eps.gz)
all_files.eps		?= $(wildcard *.eps)

# Utility function for obtaining all files not specified in $(neverclean)
# $(call cleanable-files,file1 file2 file3 ...)
# Returns the list of files that is not in $(wildcard $(neverclean))
cleanable-files = $(filter-out $(wildcard $(neverclean)), $1)

# Utility function for getting all .$1 files that are to be ignored
#  * files listed in $(includes.$1)
#  * files not listed in $(onlysources.$1) if it is defined
ignore_files = \
  $(includes.$1) \
  $(if $(onlysources.$1),$(filter-out $(onlysources.$1), $(all_files.$1)))

# Patterns to never be allowed as source targets
ignore_patterns	:= %._include_

# Patterns allowed as source targets but not included in 'all' builds
nodefault_patterns := %._nobuild_ $(ignore_patterns)

# Utility function for getting targets suitable building
# $(call filter-buildable,suffix)
filter-buildable	= \
	$(filter-out $(call ignore_files,$1) \
		$(addsuffix .$1,$(ignore_patterns)),$(all_files.$1))

# Utility function for getting targets suitable for 'all' builds
# $(call filter-default,suffix)
filter-default		= \
	$(filter-out $(call ignore_files,$1) \
		$(addsuffix .$1,$(nodefault_patterns)),$(all_files.$1))

# Top level sources that can be built even when they are not by default
files.tex	:= $(call filter-buildable,tex)
files.tex.sh	:= $(call filter-buildable,tex.sh)
files.tex.pl	:= $(call filter-buildable,tex.pl)
files.tex.py	:= $(call filter-buildable,tex.py)
files.rst	:= $(call filter-buildable,rst)
files.gpi	:= $(call filter-buildable,gpi)
files.dot	:= $(call filter-buildable,dot)
files.fig	:= $(call filter-buildable,fig)
files.xvg	:= $(call filter-buildable,xvg)
files.svg	:= $(call filter-buildable,svg)
files.png	:= $(call filter-buildable,png)
files.jpg	:= $(call filter-buildable,jpg)
files.jpeg	:= $(call filter-buildable,jpeg)
files.eps.gz	:= $(call filter-buildable,eps.gz)
files.eps	:= $(call filter-buildable,eps)

# Make all pstex targets secondary.  The pstex_t target requires the pstex
# target, and nothing else really depends on it, so it often gets deleted.
# This avoids that by allowing *all* fig files to be pstex targets, which is
# perfectly valid and causes no problems even if they're going to become eps
# files in the end.
.SECONDARY:	$(patsubst %.fig,%.pstex,$(files.fig))

# Top level sources that are built by default targets
default_files.tex	:= $(call filter-default,tex)
default_files.tex.sh	:= $(call filter-default,tex.sh)
default_files.tex.pl	:= $(call filter-default,tex.pl)
default_files.tex.py	:= $(call filter-default,tex.py)
default_files.rst	:= $(call filter-default,rst)
default_files.gpi	:= $(call filter-default,gpi)
default_files.dot	:= $(call filter-default,dot)
default_files.fig	:= $(call filter-default,fig)
default_files.xvg	:= $(call filter-default,xvg)
default_files.svg	:= $(call filter-default,svg)
default_files.png	:= $(call filter-default,png)
default_files.jpg	:= $(call filter-default,jpg)
default_files.jpeg	:= $(call filter-default,jpeg)
default_files.eps.gz	:= $(call filter-default,eps.gz)
default_files.eps	:= $(call filter-default,eps)

# Utility function for creating larger lists of files
# $(call concat-files,suffixes,[prefix])
concat-files	= $(foreach s,$1,$($(if $2,$2_,)files.$s))

# Useful file groupings
all_files_source	:= $(call concat-files,tex,all)
all_files_scripts	:= $(call concat-files,tex.sh tex.pl tex.py rst,all)

.PHONY: $(all_files_scripts)

default_files_source	:= $(call concat-files,tex,default)
default_files_scripts	:= $(call concat-files,tex.sh tex.pl tex.py rst,default)

files_source	:= $(call concat-files,tex)
files_scripts	:= $(call concat-files,tex.sh tex.pl tex.py rst)

# Utility function for obtaining stems
# $(call get-stems,suffix,[prefix])
get-stems	= $(sort $($(if $2,$2_,)files.$1:%.$1=%))

# List of all stems (including ._include_ and ._nobuild_ file stems)
all_stems.tex		:= $(call get-stems,tex,all)
all_stems.tex.sh	:= $(call get-stems,tex.sh,all)
all_stems.tex.pl	:= $(call get-stems,tex.pl,all)
all_stems.tex.py	:= $(call get-stems,tex.py,all)
all_stems.rst		:= $(call get-stems,rst,all)
all_stems.fig		:= $(call get-stems,fig,all)
all_stems.gpi		:= $(call get-stems,gpi,all)
all_stems.dot		:= $(call get-stems,dot,all)
all_stems.xvg		:= $(call get-stems,xvg,all)
all_stems.svg		:= $(call get-stems,svg,all)
all_stems.png		:= $(call get-stems,png,all)
all_stems.jpg		:= $(call get-stems,jpg,all)
all_stems.jpeg		:= $(call get-stems,jpeg,all)
all_stems.eps.gz	:= $(call get-stems,eps.gz,all)
all_stems.eps		:= $(call get-stems,eps,all)

# List of all default stems (all default PDF targets):
default_stems.tex		:= $(call get-stems,tex,default)
default_stems.tex.sh		:= $(call get-stems,tex.sh,default)
default_stems.tex.pl		:= $(call get-stems,tex.pl,default)
default_stems.tex.py		:= $(call get-stems,tex.py,default)
default_stems.rst		:= $(call get-stems,rst,default)
default_stems.fig		:= $(call get-stems,fig,default)
default_stems.gpi		:= $(call get-stems,gpi,default)
default_stems.dot		:= $(call get-stems,dot,default)
default_stems.xvg		:= $(call get-stems,xvg,default)
default_stems.svg		:= $(call get-stems,svg,default)
default_stems.png		:= $(call get-stems,png,default)
default_stems.jpg		:= $(call get-stems,jpg,default)
default_stems.jpeg		:= $(call get-stems,jpeg,default)
default_stems.eps.gz		:= $(call get-stems,eps.gz,default)
default_stems.eps		:= $(call get-stems,eps,default)

# List of all stems (all possible bare PDF targets created here):
stems.tex		:= $(call get-stems,tex)
stems.tex.sh		:= $(call get-stems,tex.sh)
stems.tex.pl		:= $(call get-stems,tex.pl)
stems.tex.py		:= $(call get-stems,tex.py)
stems.rst		:= $(call get-stems,rst)
stems.fig		:= $(call get-stems,fig)
stems.gpi		:= $(call get-stems,gpi)
stems.dot		:= $(call get-stems,dot)
stems.xvg		:= $(call get-stems,xvg)
stems.svg		:= $(call get-stems,svg)
stems.png		:= $(call get-stems,png)
stems.jpg		:= $(call get-stems,jpg)
stems.jpeg		:= $(call get-stems,jpeg)
stems.eps.gz		:= $(call get-stems,eps.gz)
stems.eps		:= $(call get-stems,eps)

# Utility function for creating larger lists of stems
# $(call concat-stems,suffixes,[prefix])
concat-stems	= $(sort $(foreach s,$1,$($(if $2,$2_,)stems.$s)))

# The most likely to be source but not finished product go first
graphic_source_extensions	:= fig \
				   gpi \
				   xvg \
				   svg \
				   dot \
				   eps.gz

ifeq "$(strip $(BUILD_STRATEGY))" "latex"
graphic_source_extensions	+= png jpg jpeg
graphic_target_extensions	:= eps ps
endif

ifeq "$(strip $(BUILD_STRATEGY))" "pdflatex"
graphic_source_extensions	+= eps
graphic_target_extensions	:= pdf png jpg jpeg mps tif
endif

ifeq "$(strip $(BUILD_STRATEGY))" "xelatex"
graphic_source_extensions	+= eps
graphic_target_extensions	:= pdf png jpg jpeg mps tif
endif

all_stems_source	:= $(call concat-stems,tex,all)
all_stems_script	:= $(call concat-stems,tex.sh tex.pl tex.py rst,all)
all_stems_graphic	:= $(call concat-stems,$(graphic_source_extensions),all)
all_stems_ss		:= $(sort $(all_stems_source) $(all_stems_script))
all_stems_sg		:= $(sort $(all_stems_script))
all_stems_ssg		:= $(sort $(all_stems_ss))

default_stems_source	:= $(call concat-stems,tex,default)
default_stems_script	:= $(call concat-stems,tex.sh tex.pl tex.py rst,default)
default_stems_ss	:= $(sort $(default_stems_source) $(default_stems_script))
default_stems_sg	:= $(sort $(default_stems_script))
default_stems_ssg	:= $(sort $(default_stems_ss))

stems_source		:= $(call concat-stems,tex)
stems_script		:= $(call concat-stems,tex.sh tex.pl tex.py rst)
stems_graphic		:= $(call concat-stems,$(graphic_source_extensions))
stems_gg		:= $(sort $(stems_graphic))
stems_ss		:= $(sort $(stems_source) $(stems_script))
stems_sg		:= $(sort $(stems_script))
stems_ssg		:= $(sort $(stems_ss))

# Calculate names that can generate the need for an include file.  We can't
# really do this with patterns because it's too easy to screw up, so we create
# an exhaustive list.
allowed_source_suffixes	:= \
	pdf \
	ps \
	dvi \
	ind \
	nls \
	bbl \
	aux \
	aux.make \
	d \
	auxbbl.make \
	_graphics \
	_show
allowed_source_patterns		:= $(addprefix %.,$(allowed_source_suffixes))

allowed_graphic_suffixes	:= \
	pdf \
	eps \
	gpihead.make \
	gpi.d
allowed_graphic_patterns	:= $(addprefix %.,$(allowed_graphic_suffixes))

# All targets allowed to build documents
allowed_source_targets	:= \
	$(foreach suff,$(allowed_source_suffixes),\
	$(addsuffix .$(suff),$(stems_ssg)))

# All targets allowed to build graphics
allowed_graphic_targets	:= \
	$(foreach suff,$(allowed_graphic_suffixes),\
	$(addsuffix .$(suff),$(stems_gg)))

# All targets that build multiple documents (like 'all')
allowed_batch_source_targets	:= \
	all \
	all-pdf \
	all-ps \
	all-dvi \
	all-bbl \
	all-ind \
	all-gls \
	all-nls \
	show

# All targets that build multiple graphics (independent of document)
allowed_batch_graphic_targets	:= \
	all-graphics \
	all-pstex \
	all-dot2tex \
	show-graphics

# Now we figure out which stuff is available as a make target for THIS RUN.
real_goals	:= $(call get-default,$(filter-out _includes,$(MAKECMDGOALS)),\
			all)

specified_source_targets	:= $(strip \
	$(filter $(allowed_source_targets) $(stems_ssg),$(real_goals)) \
	)

specified_batch_source_targets	:= $(strip \
	$(filter $(allowed_batch_source_targets),$(real_goals)) \
	)

specified_graphic_targets	:= $(strip \
	$(filter $(allowed_graphic_targets),$(real_goals)) \
	)

specified_batch_graphic_targets	:= $(strip \
	$(filter $(allowed_batch_graphic_targets),$(real_goals)) \
	)

specified_gpi_targets	:= $(patsubst %.gpi,%.$(default_graphic_extension),\
	$(filter $(patsubst %.$(default_graphic_extension),%.gpi,$(specified_graphic_targets)),\
		$(all_files.gpi)) \
	)

# Determine which .d files need including from the information gained above.
# This is done by first checking whether a batch target exists.  If it does,
# then all *default* stems are used to create possible includes (nobuild need
# not apply for batch status).  If no batch targets exist, then the individual
# targets are considered and appropriate includes are taken from them.
source_stems_to_include	:= \
	$(sort\
	$(if $(specified_batch_source_targets),\
		$(default_stems_ss),\
		$(foreach t,$(specified_source_targets),\
		$(foreach p,$(allowed_source_patterns),\
			$(patsubst $p,%,$(filter $p $(stems_ssg),$t)) \
		)) \
	))

# Determine which .gpi.d files are needed using the above information.  We
# first check whether a batch target is specified, then check individual
# graphics that may have been specified.
graphic_stems_to_include	:= \
	$(sort\
	$(if $(specified_batch_graphic_targets),\
		$(default_stems.gpi),\
		$(foreach t,$(specified_gpi_targets),\
		$(foreach p,$(allowed_graphic_patterns),\
			$(patsubst $p,%,$(filter $p,$t)) \
		)) \
	))

# All dependencies for the 'all' targets
all_pdf_targets		:= $(addsuffix .pdf,$(stems_ssg))
all_ps_targets		:= $(addsuffix .ps,$(stems_ssg))
all_dvi_targets		:= $(addsuffix .dvi,$(stems_ssg))
all_tex_targets		:= $(addsuffix .tex,$(stems_sg))
all_d_targets		:= $(addsuffix .d,$(stems_ssg))
all_graphics_targets	:= $(addsuffix .$(default_graphic_extension),$(stems_gg))
all_pstex_targets	:= $(addsuffix .pstex_t,$(stems.fig))
all_dot2tex_targets	:= $(addsuffix .dot_t,$(stems.dot))

all_known_graphics	:= $(sort $(all_graphics_targets) $(wildcard *.$(default_graphic_extension)))

default_pdf_targets	:= $(addsuffix .pdf,$(default_stems_ss))

ifeq "$(strip $(BUILD_STRATEGY))" "latex"
default_ps_targets	:= $(addsuffix .ps,$(default_stems_ss))
default_dvi_targets	:= $(addsuffix .dvi,$(default_stems_ss))
pre_pdf_extensions	:= dvi ps
endif

# Extensions generated by LaTeX invocation that can be removed when complete
rm_ext		:= \
	log *.log aux $(pre_pdf_extensions) pdf blg bbl out nav snm toc lof lot lol pfg \
	fls vrb idx ind ilg glg glo gls lox nls nlo nlg brf mtc maf brf ist
backup_patterns	:= *~ *.bak *.backup body.tmp head.tmp

graph_stem	:= _graph

# All LaTeX-generated files that can be safely removed

rm_tex := \
	$(foreach e,$(rm_ext),$(addsuffix .$e,$(all_stems_source))) \
	$(foreach e,$(rm_ext) tex,$(addsuffix .$e,$(all_stems_sg))) \
	$(addsuffix .log,$(all_ps_targets) $(all_pdf_targets)) \
	$(addsuffix .*.log,$(stems_graphic))

# These are the files that will affect .gpi transformation for all .gpi files.
#
# Use only the first one found.  Backward compatible values are at the end.
# Note that we use foreach, even though wildcard also returns a list, to ensure
# that the order in the uppercase variables is preserved.  Directory listings
# provide no such guarantee, so we avoid relying on them.
gpi_sed		:= $(strip \
	$(firstword $(foreach f,$(GNUPLOT_SED),$(wildcard $f))))
gpi_global	:= $(strip \
	$(firstword $(foreach f,$(GNUPLOT_GLOBAL),$(wildcard $f))))

#
# Functions used in generating output
#

# Outputs all source dependencies to stdout.  The first argument is the file to
# be parsed, the second is a list of files that will show up as dependencies in
# the new .d file created here.
#
# $(call get-inputs,<parsed file>,<target files>)
define get-inputs
(##include_sed("$(SED)", "get-inputs.sed", "'$1'", target_files="$2")
##) | $(SORT) | $(UNIQ)
endef

# $(call get-missing-inputs,<log file>,<target files>)
define get-missing-inputs
(##include_sed("$(SED)", "get-missing-inputs.sed", "'$1'", target_files="$2")
##) | $(SORT) | $(UNIQ)
endef

# Get source file for specified graphics stem.
#
# $(call graphics-source,<stem>)
define graphics-source
$(strip $(firstword \
	$(wildcard \
		$(addprefix $1.,\
			$(graphic_source_extensions))) \
	$1 \
))
endef

# Get the target file for the specified graphics file/stem
#
# $(call graphics-target,<stem>)
define graphics-target
$(strip $(if 	$(filter $(addprefix %.,$(graphic_target_extensions)),$1), $1,
	$(firstword $(patsubst $(addprefix %.,$(graphic_source_extensions) $(graphic_target_extensions)), %, $1).$(default_graphic_extension) $1.$(default_graphic_extension))))
endef

# Outputs all of the graphical dependencies to stdout.  The first argument is
# the stem of the source file being built, the second is a list of suffixes
# that will show up as dependencies in the generated .d file.
#
# Note that we try to escape spaces in filenames where possible.  We have to do
# it with three backslashes so that as the name percolates through the makefile
# it eventually ends up with the proper escaping when the build rule is found.
# Ugly, but it appears to work.  Note that graphicx doesn't allow filenames
# with spaces, so this could in many ways be moot unless you're using something
# like grffile.
#
# For pdflatex, we really need the missing file to be specified without an
# extension, otherwise compilation barfs on the first missing file.  Truly
# annoying, but there you have it.
#
# It turns out that the graphics errors, although they have lines with empty
# space, are only made of two paragraphs.  So, we just use some sed magic to
# get everything into paragraphs, detect when it's a paragraph that interests
# us, and double it up.  Then we get the filename only if we're missing
# extensions (a sign that it's graphicx complaining).
#
# $(call get-graphics,<target file stem>)
#.log,$(addprefix $*.,d $(build_target_extension) _graphics)
define get-graphics
(##include_sed("$(SED)", "get-graphics.sed", "$1.log",
	       stem="$1",
	       build_target_extension="$(build_target_extension)")
##)
endef

# Checks for build failure due to pstex inclusion, and gives instructions.
#
# $(call die-on-pstexs,<parsed file>)
define die-on-pstexs
if $(EGREP) -q '^! LaTeX Error: File .*\.pstex.* not found' $1; then \
	$(ECHO) "$(C_ERROR)Missing pstex_t file(s)$(C_RESET)"; \
	$(ECHO) "$(C_ERROR)Please run$(C_RESET)"; \
	$(ECHO) "$(C_ERROR)  make all-pstex$(C_RESET)"; \
	$(ECHO) "$(C_ERROR)before proceeding.$(C_RESET)"; \
	exit 1; \
fi
endef

# Checks for the use of import.sty and bails - we don't support subdirectories
#
# $(call die-on-import-sty,<log file>)
define die-on-import-sty
if $(EGREP) -s '/import.sty\)' '$1'; then \
	$(ECHO) "$(C_ERROR)import.sty is not supported - included files must"; \
	$(ECHO) "$(C_ERROR)be in the same directory as the primary document$(C_RESET)"; \
	exit 1; \
fi
endef

# Checks for build failure due to dot2tex, and gives instructions.
#
# $(call die-on-dot2tex,<parsed file>)
define die-on-dot2tex
if $(EGREP) -q ' LaTeX Error: File .*\.dot_t.* not found' $1; then \
	$(ECHO) "$(C_ERROR)Missing dot_t file(s)$(C_RESET)"; \
	$(ECHO) "$(C_ERROR)Please run$(C_RESET)"; \
	$(ECHO) "$(C_ERROR)  make all-dot2tex$(C_RESET)"; \
	$(ECHO) "$(C_ERROR)before proceeding.$(C_RESET)"; \
	exit 1; \
fi
endef

# Checks for the existence of a .aux file, and dies with an error message if it
# isn't there.  Note that we pass the file stem in, not the full filename,
# e.g., to check for foo.aux, we call it thus: $(call die-on-no-aux,foo)
#
# $(call die-on-no-aux,<aux stem>)
define die-on-no-aux
if [ ! -e '$1.aux' ]; then \
	$(call colorize-latex-errors,$1.log); \
	$(ECHO) "$(C_ERROR)Error: failed to create $1.aux$(C_RESET)"; \
	exit 1; \
fi
endef

# Outputs all index files to stdout.  Arg 1 is the source file stem, arg 2 is
# the list of targets for the discovered dependency.
#
# $(call get-log-index,<log file stem>,<target files>)
define get-log-index
(##include_sed("$(SED)", "get-log-index.sed", "'$1.log'",
	       stem="$1", target_files="$2")
##) | $(SORT) | $(UNIQ)
endef


# Outputs all bibliography files to stdout.  Arg 1 is the source stem, arg 2 is
# a list of targets for each dependency found.
#
# The script kills all lines that do not contain bibdata.  Remaining lines have
# the \bibdata macro and delimiters removed to create a dependency list.  A
# trailing comma is added, then all adjacent commas are collapsed into a single
# comma.  Then commas are replaced with the string .bib[space], and the
# trailing space is killed off.  Finally, all filename spaces are escaped.
# This produces a list of space-delimited .bib filenames, which is what the
# make dep file expects to see.
#
# Note that we give kpsewhich a bogus argument so that a failure of sed to
# produce output will not cause an error.
#
# $(call get-bibs,<aux file>,<targets>)
define get-bibs
$(SED) \
-e '/^\\bibdata/!d' \
-e 's/\\bibdata{\([^}]*\)}/\1,/' \
-e 's/,\{2,\}/,/g' \
-e 's/[[:space:]]/\\&/g' \
-e 's/,/.bib /g' \
-e 's/ \{1,\}$$//' \
$1 | $(XARGS) $(KPSEWHICH) '#######' | \
$(SED) \
-e 's!^!$2: !' | \
$(SORT) | $(UNIQ)
endef

# Makes a an aux file that only has stuff relevant to the target in it
# $(call make-auxtarget-file,<flattened-aux>,<new-aux>)
define make-auxtarget-file
$(SED) \
-e '/^\\newlabel/!d' \
$1 > $2
endef

# Makes an aux file that only has stuff relevant to the bbl in it
# $(call make-auxbbl-file,<flattened-aux>,<new-aux>)
define make-auxbbl-file
$(SED) \
-e '/^\\newlabel/d' \
$1 > $2
endef

# Makes a .gpi.d file from a .gpi file
# $(call make-gpi-d,<.gpi>,<.gpi.d>)
define make-gpi-d
$(ECHO) '# vim: ft=make' > $2; \
$(ECHO) 'ifndef INCLUDED_$(call cleanse-filename,$2)' >> $2; \
$(ECHO) 'INCLUDED_$(call cleanse-filename,$2) := 1' >> $2; \
$(call get-gpi-deps,$1,$(addprefix $(2:%.gpi.d=%).,$(GPI_OUTPUT_EXTENSION) gpi.d)) >> $2; \
$(ECHO) 'endif' >> $2;
endef

# Parse .gpi files for data and loaded dependencies, output to stdout
#
# The sed script here tries to be clever about obtaining valid
# filenames from the gpi file.  It assumes that the plot command starts its own
# line, which is not too difficult a constraint to satisfy.
#
# This command script also generates 'include' directives for every 'load'
# command in the .gpi file.  The load command must appear on a line by itself
# and the file it loads must have the suffix .gpi.  If you don't want it to be
# compiled when running make graphics, then give it a suffix of ._include_.gpi.
#
# $(call get-gpi-deps,<gpi file>,<targets>)
define get-gpi-deps
(##include_sed("$(SED)", "gpi-deps.sed", "'$1'", targets="$2")##)
endef

# Colorizes real, honest-to-goodness LaTeX errors that can't be overcome with
# recompilation.
#
# Note that we only ignore file not found errors for things that we know how to
# build, like graphics files.
#
# Also note that the output of this is piped through sed again to escape any
# backslashes that might have made it through.  This is to avoid sending things
# like "\right" to echo, which interprets \r as LF.  In bash, we could just do
# ${var//\\/\\\\}, but in other popular sh variants (like dash), this doesn't
# work.
#
# $(call colorize-latex-errors,<log file>)
define colorize-latex-errors
(##include_sed("$(SED)", "colorize-latex-errors.sed", "'$1'",
	       driver_pattern="$(hyperref_driver_pattern)",
	       driver_error="$(hyperref_driver_error)",
	       color_error="$(C_ERROR)",
	       color_reset="$(C_RESET)")
##) | $(SED) -e 's/\\\\/\\\\\\\\/g'
endef

# Colorize Makeindex errors
define colorize-makeindex-errors
(##include_sed("$(SED)", "colorize-makeindex-errors.sed", "'$1'",
	       color_error="$(C_ERROR)",
	       color_reset="$(C_RESET)")
##)
endef

# Colorize epstopdf errors
#
# $(call colorize-epstopdf-errors,<log file>)
define colorize-epstopdf-errors
(##include_sed("$(SED)", "colorize-epstopdf-errors.sed", "'$1'",
	       color_error="$(C_ERROR)",
	       color_reset="$(C_RESET)")
##)
endef

# Colorize GNUplot errors
#
# $(call colorize-gnuplot-errors,<log file>)
define colorize-gnuplot-errors
(##include_sed("$(SED)", "colorize-gnuplot-errors.sed", "$1",
	       color_error="$(C_ERROR)",
	       color_reset="$(C_RESET)")
##)
endef

# Colorize GraphViz errors
#
# $(call colorize-dot-errors,<log file>)
define colorize-dot-errors
(##include_sed("$(SED)", "colorize-dot-errors.sed", "'$1'",
	       color_error="$(C_ERROR)",
	       color_warning="$(C_WARNING)",
	       color_reset="$(C_RESET)")
##)
endef

# Get all important .aux files from the top-level .aux file and merges them all
# into a single file, which it outputs to stdout.
#
# $(call flatten-aux,<toplevel aux>,<output file>)
define flatten-aux
$(SED) \
-e '/\\@input{\(.*\)}/{' \
-e     's//\1/' \
-e     's![.:]!\\&!g' \
-e     'h' \
-e     's!.*!\\:\\\\@input{&}:{!' \
-e     'p' \
-e     'x' \
-e     's/\\././g' \
-e     's/.*/r &/p' \
-e     's/.*/d/p' \
-e     's/.*/}/p' \
-e     'd' \
-e '}' \
-e 'd' \
'$1' > "$1.$$$$.sed.make"; \
$(SED) -f "$1.$$$$.sed.make" '$1' > "$1.$$$$.make"; \
$(SED) \
-e '/^\\relax/d' \
-e '/^\\bibcite/d' \
-e 's/^\(\\newlabel{[^}]\{1,\}}\).*/\1/' \
"$1.$$$$.make" | $(SORT) > '$2'; \
$(call remove-temporary-files,$1.$$$$.make $1.$$$$.sed.make)
endef

# Generate pdf from postscript
#
# Note that we don't just call ps2pdf, since there are so many versions of that
# script on various systems.  Instead, we call the postscript interpreter
# directly.
#
# $(call ps2pdf,infile,outfile,[embed fonts])
define ps2pdf
	$(GS) \
		-dSAFER -dCompatibilityLevel=$(PS_COMPATIBILITY) \
		$(if $3,$(PS_EMBED_OPTIONS)) \
		-q -dNOPAUSE -dBATCH \
		-sDEVICE=pdfwrite -sstdout=%stderr \
		'-sOutputFile=$2' \
		-dSAFER -dCompatibilityLevel=$(PS_COMPATIBILITY) \
		$(if $3,$(PS_EMBED_OPTIONS)) \
		-c .setpdfwrite \
		-f '$1'
endef

# Colorize LaTeX output.
color_tex := \
(##include_sed("$(SED)", "color-tex.sed",
	       color_reset="$(C_RESET)",
	       color_success="$(C_SUCCESS)",
	       color_pages="$(C_PAGES)",
	       color_error="$(C_ERROR)",
	       color_warning="$(C_WARNING)",
	       color_overfull="$(C_OVERFULL)",
	       color_underfull="$(C_UNDERFULL)")
##)

# Colorize BibTeX output.
color_bib := \
(##include_sed("$(SED)", "color-bib.sed",
	       color_warning="$(C_WARNING)",
	       color_error="$(C_ERROR)",
	       color_reset="$(C_RESET)")
##)

# Make beamer output big enough to print on a full page.  Landscape doesn't
# seem to work correctly.
enlarge_beamer	= $(PSNUP) -l -1 -W128mm -H96mm -pletter

# $(call test-run-again,<source stem>)
test-run-again	= $(EGREP) -q '^(.*Rerun .*|No file $1\.[^.]+\.)$$' $1.log

# This tests whether the build target commands should be run at all, from
# viewing the log file.
# $(call test-log-for-need-to-run,<source stem>)
define test-log-for-need-to-run
$(SED) \
-e '/^No file $(call escape-fname-regex,$1)\.aux\./d' \
$1.log \
| $(EGREP) -q '^(.*Rerun .*|No file $1\.[^.]+\.|No file .+\.tex\.|LaTeX Warning: File.*)$$'
endef

# LaTeX invocations
#
# $(call latex,<tex file>,[<extra LaTeX args>])
run-latex	= $(latex_build_program) -interaction=batchmode -file-line-error $(if $2,$2,) $1 > /dev/null

# $(call latex-color-log,<LaTeX stem>)
latex-color-log	= $(color_tex) $1.log

# $(call run-makeindex,<input>,<output>,<log>,<extra flags>)
define run-makeindex
success=1; \
if ! $(MAKEINDEX) -q $1 -t $3 -o $2 $4 > /dev/null || $(EGREP) -q '^!!' $3; then \
	$(call colorize-makeindex-errors,$3); \
	$(RM) -f '$2'; \
	success=0; \
fi; \
[ "$$success" = "1" ] && $(sh_true) || $(sh_false);
endef

# This runs the given script to generate output, and it uses MAKE_RESTARTS to
# ensure that it never runs it more than once for a particular root make
# invocation.
#
# $(call run-script,<interpreter>,<input>,<output>)
define run-script
[ ! -e '$2.cookie' ] && $(ECHO) "restarts=$(RESTARTS)" > $2.cookie && $(ECHO) "level=$(MAKELEVEL)" >> $2.cookie; \
restarts=`$(SED) -n -e 's/^restarts=//p' $2.cookie`; \
level=`$(SED) -n -e 's/^level=//p' $2.cookie`; \
if $(EXPR) $(MAKELEVEL) '<=' $$level '&' $(RESTARTS) '<=' $$restarts >/dev/null; then \
	$(call echo-build,$2,$3,$(RESTARTS)-$(MAKELEVEL)); \
	$1 '$2' '$3'; \
	$(ECHO) "restarts=$(RESTARTS)" > '$2.cookie'; \
	$(ECHO) "level=$(MAKELEVEL)" >> '$2.cookie'; \
fi
endef

# BibTeX invocations
#
# $(call run-bibtex,<tex stem>)
run-bibtex	= $(BIBTEX) $1 | $(color_bib)


# $(call convert-eps-to-pdf,<eps file>,<pdf file>,[gray])
# Note that we don't use the --filter flag because it has trouble with bounding boxes that way.
define convert-eps-to-pdf
$(if $3,$(CAT) '$1' | $(call kill-ps-color) > '$1.cookie',$(CP) '$1' '$1.cookie'); \
$(EPSTOPDF) '$1.cookie' --outfile='$2' > $1.log; \
$(call colorize-epstopdf-errors,$1.log);
endef

# $(call default-gpi-fontsize,<output file>)
#
# Find the default fontsize given the *output* file (it is based on the output extension)
#
default-gpi-fontsize = $(if $(filter %.pdf,$1),$(DEFAULT_GPI_PDF_FONTSIZE),$(DEFAULT_GPI_EPS_FONTSIZE))

# $(call gpi-fontsize,<gpi file>,<output file>)
#
# Find out what the gnuplot fontsize should be.  Tries, in this order:
# - ##FONTSIZE comment in gpi file
# - ##FONTSIZE comment in global gpi file
# - default fontsize based on output type
define gpi-fontsize
$(strip $(firstword \
	$(shell $(SED) -e 's/^\#\#FONTSIZE=\([[:digit:]]\{1,\}\)/\1/p' -e 'd' $1 $(strip $(gpi_global))) \
	$(call default-gpi-fontsize,$2)))
endef

# $(call gpi-monochrome,<gpi file>,[gray])
define gpi-monochrome
$(strip $(if $2,monochrome,$(if $(shell $(EGREP) '^\#\#[[:space:]]*GRAY[[:space:]]*$$' $1 $(gpi_global)),monochrome,color)))
endef

# $(call gpi-font-entry,<output file>,<fontsize>)
#
# Get the font entry given the output file (type) and the font size.  For PDF
# it uses fsize or font, for eps it just uses the bare number.
gpi-font-entry = $(if $(filter %.pdf,$1),$(subst FONTSIZE,$2,$(GPI_FSIZE_SYNTAX)),$2)

# $(call gpi-terminal,<gpi file><output file>,[gray])
#
# Get the terminal settings for a given gpi and its intended output file
define gpi-terminal
$(if $(filter %.pdf,$2),pdf enhanced,postscript enhanced eps) \
$(call gpi-font-entry,$2,$(call gpi-fontsize,$1,$2)) \
$(call gpi-monochrome,$1,$3)
endef

# $(call gpi-embed-pdf-fonts,<input file>,<output file>)
#
define gpi-embed-pdf-fonts
$(GS) \
	-q \
	-dSAFER \
	-dNOPAUSE \
	-dBATCH \
	-sDEVICE=$(if $(filter pdf,$(GPI_OUTPUT_EXTENSION)),pdfwrite,pswrite) \
	-sOutputFile='$2' \
	-sstdout=%stderr \
	-dCompatibilityLevel=1.5 \
	-dPDFSETTINGS=/prepress \
	-c .setpdfwrite \
	-f '$1'
endef

# $(call convert-gpi,<gpi file>,<output file>,[gray])
#
define convert-gpi
$(ECHO) 'set terminal $(call gpi-terminal,$1,$2,$3)' > $1head.make; \
$(ECHO) 'set output "$2"' >> $1head.make; \
$(if $(gpi_global),$(CAT) $(gpi_global) >> $1head.make;,) \
fnames='$1head.make $1';\
$(if $(gpi_sed),\
	$(SED) -f '$(gpi_sed)' $$fnames > $1.temp.make; \
	fnames=$1.temp.make;,\
) \
success=1; \
if ! $(GNUPLOT) $$fnames 2>$1.log; then \
	$(call colorize-gnuplot-errors,$1.log); \
	success=0; \
else \
	if ! $(call gpi-embed-pdf-fonts,$2,$2.embed.make); then \
		success = 0; \
	else \
		$(call move-if-exists,$2.embed.make,$2); \
	fi; \
fi; \
$(if $(gpi_sed),$(call remove-temporary-files,$1.temp.make);,) \
$(call remove-temporary-files,$1head.make); \
[ "$$success" = "1" ] && $(sh_true) || $(sh_false);
endef

# Creation of .eps files from .png files
#
# The intermediate step of PNM (using NetPBM) produces much nicer output than
# ImageMagick's "convert" binary.  I couldn't get the right combination of
# flags to make it look nice, anyway.
#
# To handle gray scale conversion, we pipe things through ppmtopgm in the
# middle.
#
# $(call convert-png,<png file>,<eps file>)
define convert-png
$(PNGTOPNM) "$1" \
	$(if $3,| $(PPMTOPGM),) \
	| $(PNMTOPS) -noturn \
	> "$2"
endef

# Creation of .eps files from .jpg/.jpeg files
#
# Thanks to brubakee for this solution.
#
# Uses Postscript level 2 to avoid file size bloat
# $(call convert-jpg,<jpg file>,<eps file>)
define convert-jpg
$(CONVERT) $(if $3,-type Grayscale,) '$1' eps2:'$2'
endef

# Creation of .eps files from .fig files
# $(call convert-fig,<fig file>,<output file>,[gray])
convert-fig	= $(FIG2DEV) -L $(if $(filter %.pdf,$2),pdf,eps) $(if $3,-N,) $1 $2

# Creation of .pstex files from .fig files
# $(call convert-fig-pstex,<fig file>,<pstex file>)
convert-fig-pstex	= $(FIG2DEV) -L pstex $1 $2 > /dev/null 2>&1

# Creation of .pstex_t files from .fig files
# $(call convert-fig-pstex-t,<fig file>,<pstex file>,<pstex_t file>)
convert-fig-pstex-t	= $(FIG2DEV) -L pstex_t -p $3 $1 $2 > /dev/null 2>&1

# Creation of .dot_t files from .dot files
# #(call convert-dot-tex,<dot file>,<dot_t file>)
convert-dot-tex		= $(DOT2TEX) '$1' > '$2'

# Converts svg files into .eps files
#
# $(call convert-svg,<svg file>,<eps/pdf file>,[gray])
convert-svg	= $(INKSCAPE) --without-gui $(if $(filter %.pdf,$2),--export-pdf,--export-eps)='$2' '$1'

# Converts xvg files into .eps files
#
# $(call convert-xvg,<xvg file>,<eps file>,[gray])
convert-xvg	= $(XMGRACE) '$1' -printfile - -hardcopy -hdevice $(if $3,-mono,) EPS > '$2'

# Converts .eps.gz files into .eps files
#
# $(call convert-epsgz,<eps.gz file>,<eps file>,[gray])
convert-epsgz	= $(GUNZIP) -c '$1' $(if $3,| $(call kill-ps-color)) > '$2'

# Converts .eps files into .eps files (usually a no-op, but can make grayscale)
#
# $(call convert-eps,<in file>,<out file>,[gray])
convert-eps	= $(if $3,$(call kill-ps-color) $1 > $2)

# The name of the file containing special postscript commands for grayscale
gray_eps_file	:= gray.eps.make

# Changes sethsbcolor and setrgbcolor calls in postscript to always produce
# grayscale.  In general, this is accomplished by writing new versions of those
# functions into the user dictionary space, which is looked up before the
# global or system dictionaries (userdict is one of the permanent dictionaries
# in postscript and is not read-only like systemdict).
#
# For setrgbcolor, the weighted average of the triple is computed and the
# triple is replaced with three copies of that average before the original
# procedure is called: .299R + .587G + .114B
#
# For sethsbcolor, the color is first converted to RGB, then to grayscale by
# the new setrgbcolor operator as described above.  Why is this done?
# Because simply using the value component will tend to make pure colors
# white, a very undesirable thing.  Pure blue should not translate to white,
# but to some level of gray.  Conversion to RGB does the right thing.  It's
# messy, but it works.
#
# From
# http://en.wikipedia.org/wiki/HSV_color_space#Transformation_from_HSV_to_RGB,
# HSB = HSV (Value = Brightness), and the formula used to convert to RGB is
# as follows:
#
# Hi = int(floor(6 * H)) mod 6
# f = 6 * H - Hi
# p = V(1-S)
# q = V(1-fS)
# t = V(1-(1-f)S)
# if Hi = 0: R G B <-- V t p
# if Hi = 1: R G B <-- q V p
# if Hi = 2: R G B <-- p V t
# if Hi = 3: R G B <-- p q V
# if Hi = 4: R G B <-- t p V
# if Hi = 5: R G B <-- V p q
#
# The messy stack-based implementation is below
# $(call create-gray-eps-file,filename)
define create-gray-eps-file
$(ECHO) -n -e '\
/OLDRGB /setrgbcolor load def\n\
/setrgbcolor {\n\
    .114 mul exch\n\
    .587 mul add exch\n\
    .299 mul add\n\
    dup dup\n\
    OLDRGB\n\
} bind def\n\
/OLDHSB /sethsbcolor load def\n\
/sethsbcolor {\n\
    2 index                     % H V S H\n\
    6 mul floor cvi 6 mod       % Hi V S H\n\
    3 index                     % H Hi V S H\n\
    6 mul                       % 6H Hi V S H\n\
    1 index                     % Hi 6H Hi V S H\n\
    sub                         % f Hi V S H\n\
    2 index 1                   % 1 V f Hi V S H\n\
    4 index                     % S 1 V f Hi V S H\n\
    sub mul                     % p f Hi V S H\n\
    3 index 1                   % 1 V p f Hi V S H\n\
    6 index                     % S 1 V p f Hi V S H\n\
    4 index                     % f S 1 V p f Hi V S H\n\
    mul sub mul                 % q p f Hi V S H\n\
    4 index 1 1                 % 1 1 V q p f Hi V S H\n\
    5 index                     % f 1 1 V q p f Hi V S H\n\
    sub                         % (1-f) 1 V q p f Hi V S H\n\
    8 index                     % S (1-f) 1 V q p f Hi V S H\n\
    mul sub mul                 % t q p f Hi V S H\n\
    4 -1 roll pop               % t q p Hi V S H\n\
    7 -2 roll pop pop           % t q p Hi V\n\
    5 -2 roll                   % Hi V t q p\n\
    dup 0 eq\n\
    {1 index 3 index 6 index}\n\
    {\n\
        dup 1 eq\n\
        {3 index 2 index 6 index}\n\
        {\n\
            dup 2 eq\n\
            {4 index 2 index 4 index}\n\
            {\n\
                dup 3 eq\n\
                {4 index 4 index 3 index}\n\
                {\n\
                    dup 4 eq\n\
                    {2 index 5 index 3 index}\n\
                    {\n\
                        dup 5 eq\n\
                        {1 index 5 index 5 index}\n\
                        {0 0 0}\n\
                        ifelse\n\
                    }\n\
                    ifelse\n\
                }\n\
                ifelse\n\
            }\n\
            ifelse\n\
        }\n\
        ifelse\n\
    }\n\
    ifelse                      % B G R Hi V t q p\n\
    setrgbcolor\n\
    5 {pop} repeat\n\
} bind def\n'\
> $1
endef

# This actually inserts the color-killing code into a postscript file
# $(call kill-ps-color)
define kill-ps-color
$(SED) -e '/%%EndComments/r $(gray_eps_file)'
endef

# Converts graphviz .dot files into .eps files
# Grayscale is not directly supported by dot, so we pipe it through fig2dev in
# that case.
# $(call convert-dot,<dot file>,<eps file>,<log file>,[gray])
define convert-dot
$(DOT) -Tps '$1' 2>'$3' $(if $4,| $(call kill-ps-color)) > $2; \
$(call colorize-dot-errors,$3)
endef

# Convert DVI to Postscript
# $(call make-ps,<dvi file>,<ps file>,<log file>,[<paper size>])
make-ps		= \
	$(DVIPS) -z -o '$2' $(if $(filter-out BEAMER,$4),-t$(firstword $4),) '$1' \
		$(if $(filter BEAMER,$4),| $(enlarge_beamer)) > $3 2>&1

# Convert Postscript to PDF
# $(call make-pdf,<ps file>,<pdf file>,<log file>,<embed file>)
make-pdf	= \
	$(call ps2pdf,$1,$2,$(filter 1,$(shell $(CAT) '$4'))) > '$3' 2>&1

# Display information about what is being done
# $(call echo-build,<input file>,<output file>,[<run number>])
echo-build	= $(ECHO) "$(C_BUILD)= $1 --> $2$(if $3, ($3),) =$(C_RESET)"
echo-graphic	= $(ECHO) "$(C_GRAPHIC)= $1 --> $2 =$(C_RESET)"
echo-dep	= $(ECHO) "$(C_DEP)= $1 --> $2 =$(C_RESET)"

# Display a list of something
# $(call echo-list,<values>)
echo-list	= for x in $1; do $(ECHO) "$$x"; done

#
# DEFAULT TARGET
#

.PHONY: all
all: $(default_pdf_targets) ;

.PHONY: all-pdf
all-pdf: $(default_pdf_targets) ;

ifeq "$(strip $(BUILD_STRATEGY))" "latex"
.PHONY: all-ps
all-ps: $(default_ps_targets) ;

.PHONY: all-dvi
all-dvi: $(default_dvi_targets) ;
endif

#
# VIEWING TARGET
#
.PHONY: show
show: all
	$(QUIET)for x in $(default_pdf_targets); do \
		[ -e "$$x" ] && $(VIEW_PDF) $$x & \
	done

#
# INCLUDES
#
source_includes	:= $(addsuffix .d,$(source_stems_to_include))
graphic_includes := $(addsuffix .gpi.d,$(graphic_stems_to_include))

# Check the version of the makefile
ifneq "" "$(filter 3.79 3.80,$(MAKE_VERSION))"
$(warning $(C_WARNING)Your version of make is too old.  Please upgrade.$(C_RESET))
endif

# Include only the dependencies used
ifneq "" "$(source_includes)"
include $(source_includes)$(call include-message,$(source_includes))
endif
ifneq "" "$(graphic_includes)"
include $(graphic_includes)$(call include-message,$(graphic_includes))
endif

#
# MAIN TARGETS
#

# Note that we don't just say %: %.pdf here - this can tend to mess up our
# includes, which detect what kind of file we are asking for.  For example,
# asking to build foo.pdf is much different than asking to build foo when
# foo.gpi exists, because we look through all of the goals for *.pdf that
# matches *.gpi, then use that to determine which include files we need to
# build.
#
# Thus, we invoke make recursively with better arugments instead, restarting
# all of the appropriate machinery.
.PHONY: $(default_stems_ss)
$(default_stems_ss): %: %.pdf ;

# This builds and displays the wanted file.
.PHONY: $(addsuffix ._show,$(stems_ssg))
$(addsuffix ._show,$(stems_ssg)): %._show: %.pdf
	$(QUIET)$(VIEW_PDF) $< &

ifeq "$(strip $(BUILD_STRATEGY))" "latex"
.SECONDARY: $(all_pdf_targets)
%.pdf: %.ps %.embed.make
	$(QUIET)$(call echo-build,$<,$@)
	$(QUIET)$(call make-pdf,$<,$@.temp,$@.log,$*.embed.make); \
	if [ x"$$?" = x"0" ]; then \
	    $(if $(VERBOSE),$(CAT) $@.log,:); \
	    $(RM) -f '$@'; \
	    $(MV) '$@.temp' '$@'; \
	    $(TOUCH) '$@'; \
	    $(call copy-with-logging,$@,$(BINARY_TARGET_DIR)); \
	else \
	    $(CAT) $@.log; \
	    $(call remove-temporary-files,'$@.temp'); \
	    $(sh_false); \
	fi

.SECONDARY: $(all_ps_targets)
%.ps: %.dvi %.paper.make
	$(QUIET)$(call echo-build,$<,$@)
	$(QUIET)$(call make-ps,$<,$@.temp,$@.log,\
			$(firstword $(shell $(CAT) $*.paper.make))); \
	if [ x"$$?" = x"0" ]; then \
	    $(if $(VERBOSE),$(CAT) $@.log,:); \
	    $(RM) -f '$@'; \
	    $(MV) '$@.temp' '$@'; \
	    $(TOUCH) '$@'; \
	    $(call copy-with-logging,$@,$(BINARY_TARGET_DIR)); \
	else \
	    $(CAT) $@.log; \
	    $(call remove-temporary-files,'$@.temp'); \
	    $(sh_false); \
	fi
endif

# Build the final target (dvi or pdf) file.  This is a very tricky rule because
# of the way that latex runs multiple times, needs graphics after the first run
# (or maybe already has them), and relies on bibliographies or indices that may
# not exist.
#
#	Check the log for fatal errors.  If they exist, colorize and bail.
#
#	Create the .auxtarget.cookie file.  (Needed for next time if not present)
#
#	If any of the following are true, we must rebuild at least one time:
#
#	* the .bbl was recently rebuilt
#
#		check a cookie, then delete it
#
#	* any of several output files was created or changed:
#
#		check $*.run.cookie, then delete it
#
#	* the .aux file changed in a way that necessitates attention
#
#		Note that if the .auxtarget.make file doesn't exist, this means
#		that we are doing a clean build, so it doesn't figure into the
#		test for running again.
#
#		compare against .auxtarget.make
#
#		move if different, remove if not
#
#	* the .log file has errors or warnings requiring at least one more run
#
#	We use a loop over a single item to simplify the process of breaking
#	out when we find one of the conditions to be true.
#
#	If we do NOT need to run latex here, then we move the $@.1st.make file
#	over to $@ because the target file has already been built by the first
#	dependency run and is valid.
#
#	If we do, we delete that cookie file and do the normal multiple-runs
#	routine.
#
ifeq "$(strip $(BUILD_STRATEGY))" "latex"
.SECONDARY: $(all_dvi_targets)
endif
%.$(build_target_extension): %.bbl %.aux %.$(build_target_extension).1st.make
	$(QUIET)\
	fatal=`$(call colorize-latex-errors,$*.log)`; \
	if [ x"$$fatal" != x"" ]; then \
		$(ECHO) "$$fatal"; \
		exit 1; \
	fi; \
	$(call make-auxtarget-file,$*.aux.make,$*.auxtarget.cookie); \
	run=0; \
	for i in 1; do \
		if $(call test-exists,$*.bbl.cookie); then \
			run=1; \
			break; \
		fi; \
		if $(call test-exists,$*.run.cookie); then \
			run=1; \
		    	break; \
		fi; \
		if $(call \
		test-exists-and-different,$*.auxtarget.cookie,$*.auxtarget.make);\
		then \
			run=1; \
			break; \
		fi; \
		if $(call test-log-for-need-to-run,$*); then \
			run=1; \
			break; \
		fi; \
		if [ ! -e $*.1st.*.make ]; then \
			run=1; \
			break; \
		fi; \
	done; \
	$(call remove-temporary-files,$*.bbl.cookie $*.run.cookie); \
	$(MV) $*.auxtarget.cookie $*.auxtarget.make; \
	if [ x"$$run" = x"1" ]; then \
		$(call remove-files,$@.1st.make); \
		for i in 2 3 4 5; do \
			$(if $(findstring 3.79,$(MAKE_VERSION)),\
				$(call echo-build,$*.tex,$@,$(RESTARTS)-$$$$i),\
				$(call echo-build,$*.tex,$@,$(RESTARTS)-$$i)\
			); \
			$(call run-latex,$*); \
			$(CP) '$*.log' '$*.'$(RESTARTS)-$$i'.log'; \
			$(call test-run-again,$*) || break; \
		done; \
	else \
		$(MV) '$@.1st.make' '$@'; \
	fi; \
	$(call copy-with-logging,$@,$(BINARY_TARGET_DIR)); \
	$(call latex-color-log,$*)

# Build the .bbl file.  When dependencies are included, this will (or will
# not!) depend on something.bib, which we detect, acting accordingly.  The
# dependency creation also produces the %.auxbbl.make file.  BibTeX is a bit
# finicky about what you call the actual files, but we can rest assured that if
# a .auxbbl.make file exists, then the .aux file does, as well.  The
# .auxbbl.make file is a cookie indicating whether the .bbl needs to be
# rewritten.  It only changes if the .aux file changes in ways relevant to .bbl
# creation.
#
# Note that we do NOT touch the .bbl file if there is no need to
# create/recreate it.  We would like to leave existing files alone if they
# don't need to be changed, thus possibly avoiding a rebuild trigger.
%.bbl: %.auxbbl.make
	$(QUIET)\
	$(if $(filter %.bib,$^),\
		$(call echo-build,$(filter %.bib,$?) $*.aux,$@); \
		$(call run-bibtex,$*); \
		$(TOUCH) $@.cookie; \
	) \
	if $(EGREP) -q 'bibstyle.(apacite|apacann|chcagoa|[^}]*annot)' '$*.aux'; then \
		$(call echo-build,** annotated extra latex **,output ignored,$(RESTARTS)-1); \
		$(call run-latex,$*); \
		$(CP) '$*.log' '$*.$(RESTARTS)-annotated.log'; \
		$(if $(filter %.bib,$^),\
			$(call echo-build,** annotated extra bibtex ** $(filter %.bib,$?) $*.aux,$@); \
			$(call run-bibtex,$*); \
			$(TOUCH) $@.cookie; \
		) \
		$(call echo-build,** annotated extra latex **,output ignored,$(RESTARTS)-2); \
		$(call run-latex,$*); \
	fi

# Create the index file - note that we do *not* depend on %.tex here, since
# that unnecessarily restricts the kinds of indices that we can build to those
# with exactly the same stem as the source file.  Things like splitidx create
# idx files with other names.
#
# Therefore, we add the .tex dependency in the sourcestem.d file in the call to
# get index file dependencies from the logs.
%.ind:	%.idx
	$(QUIET)$(call echo-build,$<,$@)
	$(QUIET)$(call run-makeindex,$<,$@,$*.ilg)

# Create a glossary file from a .ist file
%.gls:	%.glo %.tex %.ist
	$(QUIET)$(call echo-build,$<,$@)
	$(QUIET)$(call run-makeindex,$<,$@,$*.glg,-s $*.ist)

# Create the glossary file from a nomenclature file
%.gls:	%.glo %.tex nomencl.ist
	$(QUIET)$(call echo-build,$<,$@)
	$(QUIET)$(call run-makeindex,$<,$@,$*.glg,-s nomencl.ist)

# Create the nomenclature file
%.nls:	%.nlo %.tex nomencl.ist
	$(QUIET)$(call echo-build,$<,$@)
	$(QUIET)$(call run-makeindex,$<,$@,$*.nlg,-s nomencl.ist)

# SCRIPTED LaTeX TARGETS
#
# Keep the generated .tex files around for debugging if needed.
.SECONDARY: $(all_tex_targets)

%.tex::	%.tex.sh
	$(QUIET)$(call run-script,$(SHELL),$<,$@)

%.tex::	%.tex.py
	$(QUIET)$(call run-script,$(PYTHON),$<,$@)

%.tex::	%.tex.pl
	$(QUIET)$(call run-script,$(PERL),$<,$@)

%.tex::	%.rst $(RST_STYLE_FILE)
	$(QUIET)\
	$(call run-script,$(RST2LATEX)\
		--documentoptions=letterpaper\
		$(if $(RST_STYLE_FILE),--stylesheet=$(RST_STYLE_FILE),),$<,$@)

#
# GRAPHICS TARGETS
#
.PHONY: all-graphics
all-graphics:	$(all_graphics_targets);

ifeq "$(strip $(BUILD_STRATEGY))" "latex"
.PHONY: all-pstex
all-pstex:	$(all_pstex_targets);
endif

.PHONY: all-dot2tex
all-dot2tex:	$(all_dot2tex_targets);

.PHONY: show-graphics
show-graphics: all-graphics
	$(VIEW_GRAPHICS) $(all_known_graphics)

$(gray_eps_file):
	$(QUIET)$(call echo-build,$^,$@)
	$(QUIET)$(call create-gray-eps-file,$@)

ifeq "$(strip $(BUILD_STRATEGY))" "pdflatex"
%.pdf: %.eps $(if $(GRAY),$(gray_eps_file))
	$(QUIET)$(call echo-graphic,$^,$@)
	$(QUIET)$(call convert-eps-to-pdf,$<,$@,$(GRAY))

ifeq "$(strip $(GPI_OUTPUT_EXTENSION))" "pdf"
%.pdf:	%.gpi %.gpi.d $(gpi_sed) $(gpi_global)
	$(QUIET)$(call echo-graphic,$^,$@)
	$(QUIET)$(call convert-gpi,$<,$@,$(GRAY))
endif

%.pdf:	%.fig
	$(QUIET)$(call echo-graphic,$^,$@)
	$(QUIET)$(call convert-fig,$<,$@,$(GRAY))

%.pdf:	%.svg
	$(QUIET)$(call echo-graphic,$^,$@)
	$(QUIET)$(call convert-svg,$<,$@,$(GRAY))
endif

ifeq "$(strip $(BUILD_STRATEGY))" "xelatex"
%.pdf: %.eps $(if $(GRAY),$(gray_eps_file))
	$(QUIET)$(call echo-graphic,$^,$@)
	$(QUIET)$(call convert-eps-to-pdf,$<,$@,$(GRAY))

ifeq "$(strip $(GPI_OUTPUT_EXTENSION))" "pdf"
%.pdf:	%.gpi %.gpi.d $(gpi_sed) $(gpi_global)
	$(QUIET)$(call echo-graphic,$^,$@)
	$(QUIET)$(call convert-gpi,$<,$@,$(GRAY))
endif

%.pdf:	%.fig
	$(QUIET)$(call echo-graphic,$^,$@)
	$(QUIET)$(call convert-fig,$<,$@,$(GRAY))

endif


%.eps:	%.gpi %.gpi.d $(gpi_sed) $(gpi_global)
	$(QUIET)$(call echo-graphic,$^,$@)
	$(QUIET)$(call convert-gpi,$<,$@,$(GRAY))

%.eps: %.fig
	$(QUIET)$(call echo-graphic,$^,$@)
	$(QUIET)$(call convert-fig,$<,$@,$(GRAY))

%.eps: %.dot $(if $(GRAY),$(gray_eps_file))
	$(QUIET)$(call echo-graphic,$^,$@)
	$(QUIET)$(call convert-dot,$<,$@,$<.log,$(GRAY))

%.eps: %.xvg $(if $(GRAY),$(gray_eps_file))
	$(QUIET)$(call echo-graphic,$^,$@)
	$(QUIET)$(call convert-xvg,$<,$@,$(GRAY))

ifneq "$(default_graphic_extension)" "pdf"
# We have a perfectly good build rule for svg to pdf, so we eliminate this to
# avoid confusing make (it sometimes chooses to go svg -> eps -> pdf).
%.eps: %.svg $(if $(GRAY),$(gray_eps_file))
	$(QUIET)$(call echo-graphic,$^,$@)
	$(QUIET)$(call convert-svg,$<,$@,$(GRAY))

# Similarly for these, we don't need eps if we have supported extensions
# already.
%.eps: %.jpg $(if $(GRAY),$(gray_eps_file))
	$(QUIET)$(call echo-graphic,$^,$@)
	$(QUIET)$(call convert-jpg,$<,$@,$(GRAY))

%.eps: %.jpeg $(if $(GRAY),$(gray_eps_file))
	$(QUIET)$(call echo-graphic,$^,$@)
	$(QUIET)$(call convert-jpg,$<,$@,$(GRAY))

%.eps: %.png $(if $(GRAY),$(gray_eps_file))
	$(QUIET)$(call echo-graphic,$^,$@)
	$(QUIET)$(call convert-png,$<,$@,$(GRAY))
endif

%.eps: %.eps.gz $(if $(GRAY),$(gray_eps_file))
	$(QUIET)$(call echo-graphic,$^,$@)
	$(QUIET)$(call convert-epsgz,$<,$@,$(GRAY))

%.pstex: %.fig
	$(QUIET)$(call echo-graphic,$^,$@)
	$(QUIET)$(call convert-fig-pstex,$<,$@,$(GRAY))

%.pstex_t: %.fig %.pstex
	$(QUIET)$(call echo-graphic,$^,$@)
	$(QUIET)$(call convert-fig-pstex-t,$<,$@,$*.pstex,$(GRAY))

%.dot_t: %.dot
	$(QUIET)$(call echo-graphic,$^,$@)
	$(QUIET)$(call convert-dot-tex,$<,$@)

#
# DEPENDENCY-RELATED TARGETS.
#

# Generate all of the information needed to get dependencies
# As a side effect, this creates a .dvi or .pdf file (depending on the build
# strategy).  We need to be sure to remove it if there are errors.  Errors can
# take several forms and all of them are found within the log file:
#	* There was a LaTeX error
#	* A needed file was not found
#	* Cross references need adjustment
#
# Behavior:
#	This rule is responsible for generating the following:
#	%.aux
#	%.d
#	%.aux.make
#	%.(pdf|dvi).1st.make (the .pdf or .dvi output file, moved)
#
#	Steps:
#
#	Run latex
#	Move .pdf or .dvi somewhere else (make no judgements about success)
#	Flatten the .aux file into another file
#	Add source dependencies
#	Add graphic dependencies
#	Add bib dependencies
#
#	Create cookies for various suffixes that may represent files that
#	need to be read by LaTeX in order for it to function properly.
#
#	Note that if some of the dependencies are discovered because they turn
#	up missing in the log file, we really need the .d file to be reloaded.
#	Adding a sleep command helps with this.  Otherwise make is extremely
#	nondeterministic, sometimes working, sometimes not.
#
#	Usually we can force this by simply removing the generated pdf file and
#	not creating a .1st.make file..
#
%.$(build_target_extension).1st.make %.d %.aux %.aux.make %.fls: %.tex
	$(QUIET)$(call echo-build,$<,$*.d $*.$(build_target_extension).1st.make,$(RESTARTS)-1)
	$(QUIET)\
	$(call run-latex,$<,-recorder) || $(sh_true); \
	$(CP) '$*.log' '$*.$(RESTARTS)-1.log'; \
	$(call die-on-import-sty,$*.log); \
	$(call die-on-dot2tex,$*.log); \
	$(call die-on-no-aux,$*); \
	$(call flatten-aux,$*.aux,$*.aux.make); \
	$(ECHO) "# vim: ft=make" > $*.d; \
	$(ECHO) ".PHONY: $*._graphics" >> $*.d; \
	$(call get-inputs,$*.fls,$(addprefix $*.,aux aux.make d $(build_target_extension))) >> $*.d; \
	$(call get-missing-inputs,$*.log,$(addprefix $*.,aux aux.make d $(build_target_extension))) >> $*.d; \
	$(ECHO) ".SECONDEXPANSION:" >> $*.d; \
	$(call get-graphics,$*) >> $*.d; \
	$(call get-log-index,$*,$(addprefix $*.,d aux aux.make)) >> $*.d; \
	$(call get-bibs,$*.aux.make,$(addprefix $*.,bbl aux aux.make)) >> $*.d; \
	$(EGREP) -q "# MISSING" $*.d && $(SLEEP) 1 && $(RM) $*.pdf; \
	$(call move-if-exists,$*.$(build_target_extension),$*.$(build_target_extension).1st.make); \
	for s in toc out lot lof lol nav; do \
		if [ -e "$*.$$s" ]; then \
			if ! $(DIFF) -q $*.$$s $*.$$s.make >/dev/null 2>&1; then \
				$(TOUCH) $*.run.cookie; \
			fi; \
			$(CP) $*.$$s $*.$$s.make; \
		fi; \
	done

# This is a cookie that is updated if the flattened aux file has changed in a
# way that affects the bibliography generation.
.SECONDARY: $(addsuffix .auxbbl.make,$(stems_ssg))
%.auxbbl.make: %.aux.make
	$(QUIET)\
	$(call make-auxbbl-file,$<,$@.temp); \
	$(call replace-if-different-and-remove,$@.temp,$@)

# Build a dependency file for .gpi files.  These often plot data files that
# also reside in the directory, so if a data file changes, it's nice to know
# about it.  This also handles loaded .gpi files, whose filename should have
# _include_. in it.
%.gpi.d: %.gpi
	$(QUIET)$(call echo-build,$<,$@)
	$(QUIET)$(call make-gpi-d,$<,$@)

# Store the paper size for this document -- note that if beamer is used we set
# it to the special BEAMER paper size.  We only do this, however, if the
# special comment exists, in which case we enlarge the output with psnup.
#
#	The paper size is extracted from a documentclass attribute.
%.paper.make: %.tex
	$(QUIET)$(SED) \
	-e '/\\documentclass/,/}/{' \
	-e '  s/%.*//' \
	-e '  H' \
	-e '  /}/{' \
	-e '    s/.*//' \
	-e '    x' \
	-e '    /\\documentclass/!d' \
	-e '    s/[\n[:space:]]*//g' \
	-e '    s/\([,{[]\)\([[:alnum:]]\{1,\}\)paper\([],}]\)/\1%-\2-%\3/g' \
	-e '    s/\([,{[]\)\(landscape\)\([],}]\)/\1%-\2-%\3/g' \
	-e '    s/^[^%]*%-//' \
	-e '    s/-%[^%]*$$//' \
	-e '    s/-%[^%]%-/ /g' \
	-e '    p' \
	-e '  }' \
	-e '  d' \
	-e '}' \
	-e 'd' \
	$< > $@; \
	$(EGREP) -q '^[^%]*\\documentclass[^{]*{beamer}' $< && \
	(\
		$(EGREP) -q '^%%[[:space:]]*BEAMER[[:space:]]*LARGE$$' $< && \
		$(ECHO) "BEAMER" > $@ || \
		: > $@ \
	) || $(sh_true)

# Store embedding instructions for this document using a special comment
%.embed.make: %.tex
	$(QUIET)$(EGREP) '^%%[[:space:]]*NO[[:space:]]*EMBED[[:space:]]*$$' $< \
		&& $(ECHO) '' > $@ \
		|| $(ECHO) '1' > $@;

#
# HELPFUL PHONY TARGETS
#

.PHONY: _all_programs
_all_programs:
	$(QUIET)$(ECHO) "== All External Programs Used =="
	$(QUIET)$(call output-all-programs)

.PHONY: _check_programs
_check_programs:
	$(QUIET)$(ECHO) "== Checking Makefile Dependencies =="; $(ECHO)
	$(QUIET) \
	allprogs=`\
	 ($(call output-all-programs)) | \
	 $(SED) \
	 -e 's/^[[:space:]]*//' \
	 -e '/^#/d' \
	 -e 's/[[:space:]]*#.*//' \
	 -e '/^=/s/[[:space:]]/_/g' \
	 -e '/^[[:space:]]*$$/d' \
	 -e 's/^[^=].*=[[:space:]]*\([^[:space:]]\{1,\}\).*$$/\\1/' \
	 `; \
	spaces='                             '; \
	for p in $${allprogs}; do \
	case $$p in \
		=*) $(ECHO); $(ECHO) "$$p";; \
		*) \
			$(ECHO) -n "$$p:$$spaces" | $(SED) -e 's/^\(.\{0,20\}\).*$$/\1/'; \
			loc=`$(WHICH) $$p`; \
			if [ x"$$?" = x"0" ]; then \
				$(ECHO) "$(C_SUCCESS)Found:$(C_RESET) $$loc"; \
			else \
				$(ECHO) "$(C_FAILURE)Not Found$(C_RESET)"; \
			fi; \
			;; \
	esac; \
	done

.PHONY: _check_gpi_files
_check_gpi_files:
	$(QUIET)$(ECHO) "== Checking all .gpi files for common errors =="; \
	$(ECHO); \
	for f in $(files.gpi); do \
	result=`$(EGREP) '^([^#]*set terminal |set output )' $$f`; \
	$(ECHO) -n "$$f: "; \
	if [ x"$$result" = x"" ]; then \
		$(ECHO) "$(C_SUCCESS)Okay$(C_RESET)"; \
	else \
		$(ECHO) "$(C_FAILURE)Warning: Problematic commands:$(C_RESET)";\
		$(ECHO) "$(C_ERROR)$$result$(C_RESET)"; \
	fi; \
	done; \
	$(ECHO)

.PHONY: _all_stems
_all_stems:
	$(QUIET)$(ECHO) "== All Stems =="
	$(QUIET)$(call echo-list,$(sort $(default_stems_ss)))

.PHONY: _includes
_includes:
	$(QUIET)$(ECHO) "== Include Stems =="
	$(QUIET)$(ECHO) "=== Sources ==="
	$(QUIET)$(call echo-list,$(sort $(source_includes)))
	$(QUIET)$(ECHO) "=== Graphics ==="
	$(QUIET)$(call echo-list,$(sort $(graphic_includes)))

.PHONY: _all_sources
_all_sources:
	$(QUIET)$(ECHO) "== All Sources =="
	$(QUIET)$(call echo-list,$(sort $(all_files.tex)))

.PHONY: _dependency_graph
_dependency_graph:
	$(QUIET)$(ECHO) "/* LaTeX Dependency Graph */"
	$(QUIET)$(call output-dependency-graph)

.PHONY: _show_dependency_graph
_show_dependency_graph:
	$(QUIET)$(call output-dependency-graph,$(graph_stem).dot)
	$(QUIET)$(DOT) -Tps -o $(graph_stem).eps $(graph_stem).dot
	$(QUIET)$(VIEW_POSTSCRIPT) $(graph_stem).eps
	$(QUIET)$(call remove-temporary-files,$(graph_stem).*)

.PHONY: _sources
_sources:
	$(QUIET)$(ECHO) "== Sources =="
	$(QUIET)$(call echo-list,$(sort $(files.tex)))

.PHONY: _scripts
_scripts:
	$(QUIET)$(ECHO) "== Scripts =="
	$(QUIET)$(call echo-list,$(sort $(files_scripts)))

.PHONY: _graphic_outputs
_graphic_outputs:
	$(QUIET)$(ECHO) "== Graphic Outputs =="
	$(QUIET)$(call echo-list,$(sort $(all_graphics_targets)))

.PHONY: _env
_env:
ifdef .VARIABLES
	$(QUIET)$(ECHO) "== MAKE VARIABLES =="
	$(QUIET)$(call echo-list,$(foreach var,$(sort $(.VARIABLES)),'$(var)'))
endif
	$(QUIET)$(ECHO) "== ENVIRONMENT =="
	$(QUIET)$(ENV)

#
# CLEAN TARGETS
#
# clean-generated is somewhat unique - it relies on the .fls file being
# properly built so that it can determine which of the files was generated, and
# which was not.  Expect it to silently fail if the .fls file is missing.
#
# This is used to, e.g., clean up index files that are generated by the LaTeX.
.PHONY: clean-generated
clean-generated:
	$(QUIET)$(call clean-files,$(foreach e,$(addsuffix .fls,$(all_stems_source)),\
						$(shell $(call get-generated-names,$e))))

.PHONY: clean-deps
clean-deps:
	$(QUIET)$(call clean-files,$(all_d_targets) *.make *.make.temp *.cookie)

.PHONY: clean-tex
clean-tex: clean-deps
	$(QUIET)$(call clean-files,$(rm_tex))

.PHONY: clean-graphics
# TODO: This *always* deletes pstex files, even if they were not generated by
# anything....  In other words, if you create a pstex and pstex_t pair by hand
# an drop them in here without the generating fig file, they will be deleted
# and you won't get them back.  It's a hack put in here because I'm not sure we
# even want to keep pstex functionality, so my motivation is not terribly high
# for doing it right.
clean-graphics:
	$(QUIET)$(call clean-files,$(all_graphics_targets) *.gpi.d *.pstex *.pstex_t *.dot_t)

.PHONY: clean-backups
clean-backups:
	$(QUIET)$(call clean-files,$(backup_patterns) *.temp)

.PHONY: clean-auxiliary
clean-auxiliary:
	$(QUIET)$(call clean-files,$(graph_stem).*)

.PHONY: clean-nographics
clean-nographics: clean-tex clean-deps clean-backups clean-auxiliary ;

.PHONY: clean
clean: clean-generated clean-tex clean-graphics clean-deps clean-backups clean-auxiliary ;

#
# HELP TARGETS
#

.PHONY: help
help:
	$(help_text)

.PHONY: version
version:
	$(QUIET)\
	$(ECHO) "$(fileinfo) Version $(version)"; \
	$(ECHO) "by $(author)"; \

#
# HELP TEXT
#

define help_text
(##include_as_comment("help") ##)
endef

#
# DEPENDENCY CHART:
#
(##include_as_comment("dependency-chart.dot") ##)

#
# DEPENDENCY CHART SCRIPT
#
# $(call output_dependency_graph,[<output file>])
define output-dependency-graph
	if [ -f '$(this_file)' ]; then \
	$(SED) \
		-e '/^[[:space:]]*#[[:space:]]*DEPENDENCY CHART:/,/^$$/!d' \
		-e '/DEPENDENCY CHART/d' \
		-e '/^$$/d' \
		-e 's/^[[:space:]]*#//' \
		$(this_file) $(if $1,> '$1',); \
	else \
		$(ECHO) "Cannot determine the name of this makefile."; \
	fi
endef
# vim: noet sts=0 sw=8 ts=8
